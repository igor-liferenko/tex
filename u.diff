use headers for automatic conversion of input and output to and from UTF-8
> #include <wchar.h>
> #include <locale.h>

in §20 of tex.web it is said:
The TEX processor converts between ASCII code and the user’s external character set by means of
arrays xord and xchr that are analogous to Pascal’s ord and chr functions.
make xord more analogous to ord by making it a function.
xchr array must be before xord function because xchr array is used in xord function
< ASCII_code @!xord[256];
<    /*specifies conversion of input characters*/ 
< uint8_t @!xchr[256];
---
> wchar_t @!xchr[256];
585a586,587
> uint8_t xord(wchar_t wc)
>    { int i; @<specifies conversion of input characters@> }

597,691c599,693
< xchr[040]= ' ' ;
< xchr[041]= '!' ;
< xchr[042]= '"' ;
< xchr[043]= '#' ;
< xchr[044]= '$' ;
< xchr[045]= '%' ;
< xchr[046]= '&' ;
< xchr[047]= '\'' ;@/
< xchr[050]= '(' ;
< xchr[051]= ')' ;
< xchr[052]= '*' ;
< xchr[053]= '+' ;
< xchr[054]= ',' ;
< xchr[055]= '-' ;
< xchr[056]= '.' ;
< xchr[057]= '/' ;@/
< xchr[060]= '0' ;
< xchr[061]= '1' ;
< xchr[062]= '2' ;
< xchr[063]= '3' ;
< xchr[064]= '4' ;
< xchr[065]= '5' ;
< xchr[066]= '6' ;
< xchr[067]= '7' ;@/
< xchr[070]= '8' ;
< xchr[071]= '9' ;
< xchr[072]= ':' ;
< xchr[073]= ';' ;
< xchr[074]= '<' ;
< xchr[075]= '=' ;
< xchr[076]= '>' ;
< xchr[077]= '?' ;@/
< xchr[0100]= '@@' ;
< xchr[0101]= 'A' ;
< xchr[0102]= 'B' ;
< xchr[0103]= 'C' ;
< xchr[0104]= 'D' ;
< xchr[0105]= 'E' ;
< xchr[0106]= 'F' ;
< xchr[0107]= 'G' ;@/
< xchr[0110]= 'H' ;
< xchr[0111]= 'I' ;
< xchr[0112]= 'J' ;
< xchr[0113]= 'K' ;
< xchr[0114]= 'L' ;
< xchr[0115]= 'M' ;
< xchr[0116]= 'N' ;
< xchr[0117]= 'O' ;@/
< xchr[0120]= 'P' ;
< xchr[0121]= 'Q' ;
< xchr[0122]= 'R' ;
< xchr[0123]= 'S' ;
< xchr[0124]= 'T' ;
< xchr[0125]= 'U' ;
< xchr[0126]= 'V' ;
< xchr[0127]= 'W' ;@/
< xchr[0130]= 'X' ;
< xchr[0131]= 'Y' ;
< xchr[0132]= 'Z' ;
< xchr[0133]= '[' ;
< xchr[0134]= '\\' ;
< xchr[0135]= ']' ;
< xchr[0136]= '^' ;
< xchr[0137]= '_' ;@/
< xchr[0140]= '`' ;
< xchr[0141]= 'a' ;
< xchr[0142]= 'b' ;
< xchr[0143]= 'c' ;
< xchr[0144]= 'd' ;
< xchr[0145]= 'e' ;
< xchr[0146]= 'f' ;
< xchr[0147]= 'g' ;@/
< xchr[0150]= 'h' ;
< xchr[0151]= 'i' ;
< xchr[0152]= 'j' ;
< xchr[0153]= 'k' ;
< xchr[0154]= 'l' ;
< xchr[0155]= 'm' ;
< xchr[0156]= 'n' ;
< xchr[0157]= 'o' ;@/
< xchr[0160]= 'p' ;
< xchr[0161]= 'q' ;
< xchr[0162]= 'r' ;
< xchr[0163]= 's' ;
< xchr[0164]= 't' ;
< xchr[0165]= 'u' ;
< xchr[0166]= 'v' ;
< xchr[0167]= 'w' ;@/
< xchr[0170]= 'x' ;
< xchr[0171]= 'y' ;
< xchr[0172]= 'z' ;
< xchr[0173]= '{' ;
< xchr[0174]= '|' ;
< xchr[0175]= '}' ;
< xchr[0176]= '~' ;@/
---
> xchr[040]= L' ' ;
> xchr[041]= L'!' ;
> xchr[042]= L'"' ;
> xchr[043]= L'#' ;
> xchr[044]= L'$' ;
> xchr[045]= L'%' ;
> xchr[046]= L'&' ;
> xchr[047]= L'\'' ;@/
> xchr[050]= L'(' ;
> xchr[051]= L')' ;
> xchr[052]= L'*' ;
> xchr[053]= L'+' ;
> xchr[054]= L',' ;
> xchr[055]= L'-' ;
> xchr[056]= L'.' ;
> xchr[057]= L'/' ;@/
> xchr[060]= L'0' ;
> xchr[061]= L'1' ;
> xchr[062]= L'2' ;
> xchr[063]= L'3' ;
> xchr[064]= L'4' ;
> xchr[065]= L'5' ;
> xchr[066]= L'6' ;
> xchr[067]= L'7' ;@/
> xchr[070]= L'8' ;
> xchr[071]= L'9' ;
> xchr[072]= L':' ;
> xchr[073]= L';' ;
> xchr[074]= L'<' ;
> xchr[075]= L'=' ;
> xchr[076]= L'>' ;
> xchr[077]= L'?' ;@/
> xchr[0100]= L'@@' ;
> xchr[0101]= L'A' ;
> xchr[0102]= L'B' ;
> xchr[0103]= L'C' ;
> xchr[0104]= L'D' ;
> xchr[0105]= L'E' ;
> xchr[0106]= L'F' ;
> xchr[0107]= L'G' ;@/
> xchr[0110]= L'H' ;
> xchr[0111]= L'I' ;
> xchr[0112]= L'J' ;
> xchr[0113]= L'K' ;
> xchr[0114]= L'L' ;
> xchr[0115]= L'M' ;
> xchr[0116]= L'N' ;
> xchr[0117]= L'O' ;@/
> xchr[0120]= L'P' ;
> xchr[0121]= L'Q' ;
> xchr[0122]= L'R' ;
> xchr[0123]= L'S' ;
> xchr[0124]= L'T' ;
> xchr[0125]= L'U' ;
> xchr[0126]= L'V' ;
> xchr[0127]= L'W' ;@/
> xchr[0130]= L'X' ;
> xchr[0131]= L'Y' ;
> xchr[0132]= L'Z' ;
> xchr[0133]= L'[' ;
> xchr[0134]= L'\\' ;
> xchr[0135]= L']' ;
> xchr[0136]= L'^' ;
> xchr[0137]= L'_' ;@/
> xchr[0140]= L'`' ;
> xchr[0141]= L'a' ;
> xchr[0142]= L'b' ;
> xchr[0143]= L'c' ;
> xchr[0144]= L'd' ;
> xchr[0145]= L'e' ;
> xchr[0146]= L'f' ;
> xchr[0147]= L'g' ;@/
> xchr[0150]= L'h' ;
> xchr[0151]= L'i' ;
> xchr[0152]= L'j' ;
> xchr[0153]= L'k' ;
> xchr[0154]= L'l' ;
> xchr[0155]= L'm' ;
> xchr[0156]= L'n' ;
> xchr[0157]= L'o' ;@/
> xchr[0160]= L'p' ;
> xchr[0161]= L'q' ;
> xchr[0162]= L'r' ;
> xchr[0163]= L's' ;
> xchr[0164]= L't' ;
> xchr[0165]= L'u' ;
> xchr[0166]= L'v' ;
> xchr[0167]= L'w' ;@/
> xchr[0170]= L'x' ;
> xchr[0171]= L'y' ;
> xchr[0172]= L'z' ;
> xchr[0173]= L'{' ;
> xchr[0174]= L'|' ;
> xchr[0175]= L'}' ;
> xchr[0176]= L'~' ;@/

do mapping here directly because printable characters are integrated into tex.w at ctangle
level, not at C level, due to design of web2w which does not use pool file
< for (i=0; i<=037; i++) xchr[i]= ' ' ;
< for (i=0177; i<=0377; i++) xchr[i]= ' ' ;
---
> for (i=0; i<=037; i++) xchr[i] = L' ';
> for (i=0177; i<=0377; i++) xchr[i] = L' ';
> @i mapping

xord function works analogously to xord array. it requires more processing, though,
but it is unavoidable, because array cannot be indexed by 32-bit value
< @<Set init...@>=
< for (i=first_text_char; i<=last_text_char; i++) xord[chr(i)]=invalid_code;
< for (i=0200; i<=0377; i++) xord[xchr[i]]=i;
< for (i=0; i<=0176; i++) xord[xchr[i]]=i;
---
> @<spec...@>=
> for (i=0176; i>=0; i--) if (xchr[i] == wc) return i;
> for (i=0200; i<=0377; i++) if (xchr[i] == wc) return i;
> return invalid_code;

778c781
< typedef struct {@+FILE *f;@+text_char@,d;@+} alpha_file; /*files that contain textual data*/ 
---
> typedef struct {@+FILE *f;@+wchar_t@,d;@+} alpha_file; /*files that contain textual data*/

827c830
< {@+reset((*f), name_of_file,"r");return reset_OK((*f));
---
> {@+a_reset((*f), name_of_file,"r");return reset_OK((*f));

942c945
< if (bypass_eoln) if (!eof((*f))) get((*f));
---
> if (bypass_eoln) if (!eof((*f))) a_get((*f));

953c956
<     buffer[last]=xord[(*f).d];get((*f));incr(last);
---
>     buffer[last]=xord((*f).d);a_get((*f));incr(last);

1072c1075
< loop@+{@+wake_up_terminal;write(term_out,"**");update_terminal;
---
> loop@+{@+wake_up_terminal;write(term_out,L"**");update_terminal;

1076c1079
<     write(term_out,"! End of file on the terminal... why?");
---
>     write(term_out,L"! End of file on the terminal... why?");

pool files are not used in web2w, so remove unused code
1327,1357c1330,1331
< {@+int k;@+for(k=1; k<=file_name_size;k++)name_of_file[k]=pool_name[k-1];@+} /*we needn't set |name_length|*/ 
< if (a_open_in(&pool_file)) 
<   {@+c=false;
<   @/do@+{@<Read one string, but return |false| if the string memory space is getting
< too tight for comfort@>;
<   }@+ while (!(c));
<   a_close(&pool_file);return true;
<   } 
< else bad_pool("! I can't read TEX.POOL.")
< @.I can't read TEX.POOL@>
< 
< @ @<Read one string...@>=
< {@+if (eof(pool_file)) bad_pool("! TEX.POOL has no check sum.");
< @.TEX.POOL has no check sum@>
< read(pool_file, m);@+read(pool_file, n); /*read two digits of string length*/ 
< if (m== '*' ) @<Check the pool check sum@>@;
< else{@+if ((xord[m] < '0')||(xord[m] > '9')||@|
<       (xord[n] < '0')||(xord[n] > '9')) 
<     bad_pool("! TEX.POOL line doesn't begin with two digits.");
< @.TEX.POOL line doesn't...@>
<   l=xord[m]*10+xord[n]-'0'*11; /*compute the length*/ 
<   if (pool_ptr+l+string_vacancies > pool_size) 
<     bad_pool("! You have to increase POOLSIZE.");
< @.You have to increase POOLSIZE@>
<   for (k=1; k<=l; k++) 
<     {@+if (eoln(pool_file)) m= ' ' ;@+else read(pool_file, m);
<     append_char(xord[m]);
<     } 
<   read_ln(pool_file);g=make_string();
<   } 
< } 
---
> 
> @ 

1364,1377d1337
< @<Check the pool check sum@>=
< {@+a=0;k=1;
< loop@+{@+if ((xord[n] < '0')||(xord[n] > '9')) 
<   bad_pool("! TEX.POOL check sum doesn't have nine digits.");
< @.TEX.POOL check sum...@>
<   a=10*a+xord[n]-'0';
<   if (k==9) goto done;
<   incr(k);read(pool_file, n);
<   } 
< done: if (a!=0) bad_pool("! TEX.POOL doesn't match; TANGLE me again.");
< @.TEX.POOL doesn't match@>
< c=true;
< } 
< 

define functions for handling text files
> #define a_get(file)    @[((file).d = fgetwc((file).f))@]
1452a1414,1415
> #define a_reset(file,name,mode)   @[((file).f=fopen((char *)(name)+1,mode),\
>                                  (file).f!=NULL?a_get(file):0)@]

1457,1458c1420,1421
< #define eof(file)    @[feof((file).f)@]
> #define eof(file)    @[(feof((file).f)||ferror((file).f))@]
invalid UTF-8 sequence is considered as end of file

< #define eoln(file)    @[((file).d=='\n'||eof(file))@]
---
> #define eoln(file)    @[((file).d==L'\n'||eof(file))@]




1464,1465c1427,1428
< #define write(file, format,...)    @[fprintf(file.f,format,## __VA_ARGS__)@]
< #define write_ln(file,...)	   @[write(file,__VA_ARGS__"\n")@]
---
> #define write(file, format,...)    @[fwprintf(file.f,format,## __VA_ARGS__)@]
> #define write_ln(file,...)	   @[write(file,__VA_ARGS__ L"\n")@]

1468,1469c1431,1432
< #define wterm_ln(format,...)	@[wterm(format "\n", ## __VA_ARGS__)@]
< #define wterm_cr	        @[write(term_out,"\n")@]
---
> #define wterm_ln(format,...)	@[wterm(format L"\n", ## __VA_ARGS__)@]
> #define wterm_cr	        @[write(term_out,L"\n")@]

1471,1472c1434,1435
< #define wlog_ln(format, ...)   @[wlog(format "\n", ## __VA_ARGS__)@]
< #define wlog_cr	        @[write(log_file,"\n")@]
---
> #define wlog_ln(format, ...)   @[wlog(format L"\n", ## __VA_ARGS__)@]
> #define wlog_cr	        @[write(log_file,L"\n")@]

1503c1466
< case term_and_log: {@+wterm("%c",xchr[s]);wlog("%c",xchr[s]);
---
> case term_and_log: {@+wterm(L"%lc",xchr[s]);wlog(L"%lc",xchr[s]);

1512c1475
< case log_only: {@+wlog("%c",xchr[s]);incr(file_offset);
---
> case log_only: {@+wlog(L"%lc",xchr[s]);incr(file_offset);

1515c1478
< case term_only: {@+wterm("%c",xchr[s]);incr(term_offset);
---
> case term_only: {@+wterm(L"%lc",xchr[s]);incr(term_offset);

1522c1485
< default:write(write_file[selector],"%c", xchr[s]);
---
> default:write(write_file[selector],L"%lc", xchr[s]);

1591,1592c1554,1555
< wterm("%s",banner);
< if (format_ident==0) wterm_ln(" (no format preloaded)");
---
> wterm(L"%s",banner);
> if (format_ident==0) wterm_ln(L" (no format preloaded)");

convert file name from internal encoding to UTF-8
freeze the value of k if the next multibyte sequence does not fit into the buffer
it is ok, because value of k is irrelevant in original anyway if buffer size is
depassed, as file_name_size is used instead of it
< @d append_to_name(X)	{@+c=X;incr(k);
<   if (k <= file_name_size) name_of_file[k]=xchr[c];
<   } 
---
> @d append_to_name(X)	{@+c=X;
>   if (k >= 0) {
>     char mb[MB_CUR_MAX];
>     int len = wctomb(mb, xchr[c]);
>     if (k+len <= file_name_size)
>       for (int i = 0; i < len; i++) name_of_file[++k] = mb[i];
>     else
>       k = -k;
>   }
> }

unfreeze the value of k
> if (k < 0) k = -k;

I did this, but decided to remove it to keep number of changes to the minimum.
This feature is not used in practice.
This is only used in trip test, but there it is ascii, so do not convert.
< for (j=1; j<=n; j++) append_to_name(xord[TEX_format_default[j]]);
---
> for (j=1; j<=n; j++) append_to_name(TEX_format_default[j]);

10170c10141
<   append_to_name(xord[TEX_format_default[j]]);
---
>   append_to_name(TEX_format_default[j]);

10196c10167
<   wterm_ln("Sorry, I can't find that format; will try PLAIN.");
---
>   wterm_ln(L"Sorry, I can't find that format; will try PLAIN.");

10204c10175
<   wterm_ln("I can't find the PLAIN format file!");
---
>   wterm_ln(L"I can't find the PLAIN format file!");

convert file name from UTF-8 to internal encoding
< else{@+for (k=1; k<=name_length; k++) append_char(xord[name_of_file[k]]);
---
> else{@+for (k=1; k<=name_length; k++) {
>       wchar_t wc;
>       int len = mbtowc(&wc, name_of_file+k, MB_CUR_MAX);
>       append_char(xord(wc));
>       k += len - 1;
>     }

10397c10373
< {@+wlog("%s",banner);
---
> {@+wlog(L"%s",banner);

10400c10376
< for (k=3*month-2; k<=3*month; k++) wlog("%c",months[k]);
---
> for (k=3*month-2; k<=3*month; k++) wlog(L"%c",months[k]);

"write" macro is used for binary output only here, so don't use it;
redefine it for UTF-8 because in other places it is used for text output
< for (k=a; k<=b; k++) write(dvi_file, "%c", dvi_buf[k]);
---
> for (k=a; k<=b; k++) fprintf(dvi_file.f, "%c", dvi_buf[k]);

23784c23760
<   wterm_ln("---! Must increase the %s", X);
---
>   wterm_ln(L"---! Must increase the %s", X);

23805c23781
<   wterm_ln("(Fatal format file error; I'm stymied)");
---
>   wterm_ln(L"(Fatal format file error; I'm stymied)");

24291a24268
> setlocale(LC_CTYPE, "C.UTF-8");

24297,24298c24274,24275
<   {@+wterm_ln("Ouch---my internal constants have been clobbered!"
<     "---case %d", bad);
---
>   {@+wterm_ln(L"Ouch---my internal constants have been clobbered!"
>     L"---case %d", bad);

24355,24356c24332,24333
<   {@+wlog_ln(" ");
<   wlog_ln("Here is how much of TeX's memory you used:");
---
>   {@+wlog_ln(L" ");
>   wlog_ln(L"Here is how much of TeX's memory you used:");

24358,24361c24335,24338
<   wlog(" %d string", str_ptr-init_str_ptr);
<   if (str_ptr!=init_str_ptr+1) wlog( "s" );
<   wlog_ln( " out of %d", max_strings-init_str_ptr);@/
<   wlog_ln( " %d string characters out of %d", pool_ptr-init_pool_ptr,
---
>   wlog(L" %d string", str_ptr-init_str_ptr);
>   if (str_ptr!=init_str_ptr+1) wlog( L"s" );
>   wlog_ln( L" out of %d", max_strings-init_str_ptr);@/
>   wlog_ln( L" %d string characters out of %d", pool_ptr-init_pool_ptr,

24363c24340
<   wlog_ln(" %d words of memory out of %d", lo_mem_max-mem_min+mem_end-hi_mem_min+2,@|
---
>   wlog_ln(L" %d words of memory out of %d", lo_mem_max-mem_min+mem_end-hi_mem_min+2,@|

24365,24372c24342,24349
<   wlog_ln(" %d multiletter control sequences out of %d", cs_count, hash_size);@/
<   wlog(" %d words of font info for %d font", fmem_ptr, font_ptr-font_base);
<   if (font_ptr!=font_base+1) wlog("s");
<   wlog_ln( ", out of %d for %d", font_mem_size, font_max-font_base);@/
<   wlog(" %d hyphenation exception", hyph_count);
<   if (hyph_count!=1) wlog("s");
<   wlog_ln( " out of %d", hyph_size);@/
<   wlog_ln(" %di,%dn,%dp,%db,%ds stack positions out of %di,%dn,%dp,%db,%ds", 
---
>   wlog_ln(L" %d multiletter control sequences out of %d", cs_count, hash_size);@/
>   wlog(L" %d words of font info for %d font", fmem_ptr, font_ptr-font_base);
>   if (font_ptr!=font_base+1) wlog(L"s");
>   wlog_ln( L", out of %d for %d", font_mem_size, font_max-font_base);@/
>   wlog(L" %d hyphenation exception", hyph_count);
>   if (hyph_count!=1) wlog(L"s");
>   wlog_ln( L" out of %d", hyph_size);@/
>   wlog_ln(L" %di,%dn,%dp,%db,%ds stack positions out of %di,%dn,%dp,%db,%ds",

24501c24478
<   if (fscanf(term_in.f," %d",&m)<1 ||
---
>   if (fwscanf(term_in.f,L" %d",&m)<1 ||

24507c24484
<   else{@+fscanf(term_in.f," %d",&n);
---
>   else{@+fwscanf(term_in.f,L" %d",&n);

24533c24510
< case 13: {@+fscanf(term_in.f," %d",&l);print_cmd_chr(n, l);
---
> case 13: {@+fwscanf(term_in.f,L" %d",&l);print_cmd_chr(n, l);
