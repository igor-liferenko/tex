--- web2w/tex.w	2020-06-30 08:00:45.036692434 +0700
+++ tex.w	2020-06-30 08:12:22.189472049 +0700
@@ -344,9 +344,11 @@
 #include <stdlib.h>
 #include <string.h>
 #include <math.h>
+#include <wchar.h>
+#include <locale.h>
 
 #define odd(X)       ((X)&1)
-#define chr(X)       ((unsigned char)(X))
+#define chr(X)       (X) /* fix ctex.patch */
 #define ord(X)       ((int)(X))
 #define abs(X)       ((X)>-(X)?(X):-(X))
 #define round(X)     ((int)((X)>=0.0?floor((X)+0.5):ceil((X)-0.5)))
@@ -567,9 +569,9 @@
 adjusted if necessary.
 @^system dependencies@>
 
-@d text_char	unsigned char /*the data type of characters in text files*/ 
+@d text_char	wchar_t /*the data type of characters in text files*/ 
 @d first_text_char	0 /*ordinal number of the smallest element of |text_char|*/ 
-@d last_text_char	255 /*ordinal number of the largest element of |text_char|*/ 
+@d last_text_char	65535 /*ordinal number of the largest element of |text_char|*/ 
 
 @<Local variables for init...@>=
 int @!i;
@@ -579,9 +581,9 @@
 that are analogous to \PASCAL's |ord| and |chr| functions.
 
 @<Glob...@>=
-ASCII_code @!xord[256];
+ASCII_code @!xord[65536];
    /*specifies conversion of input characters*/ 
-uint8_t @!xchr[256];
+text_char @!xchr[256]; /* fix web2w */
    /*specifies conversion of output characters*/ 
 
 @ Since we are assuming that our \PASCAL\ system is able to read and
@@ -727,6 +729,7 @@
 @<Set init...@>=
 for (i=0; i<=037; i++) xchr[i]= ' ' ;
 for (i=0177; i<=0377; i++) xchr[i]= ' ' ;
+@i mapping.w
 
 @ The following system-independent code makes the |xord| array contain a
 suitable inverse to the information in |xchr|. Note that if |xchr[i]==xchr[j]|
@@ -824,7 +827,7 @@
 
 @p bool a_open_in(alpha_file *f)
    /*open a text file for input*/ 
-{@+reset((*f), name_of_file,"r");return reset_OK((*f));
+{@+if(((*f).f=fopen(name_of_file+1,"r"))!=NULL)(*f).d=fgetwc((*f).f);return reset_OK((*f));
 } 
 @#
 bool a_open_out(alpha_file *f)
@@ -939,7 +942,7 @@
 @p bool input_ln(alpha_file *f, bool @!bypass_eoln)
    /*inputs the next line or returns |false|*/ 
 {@+uint16_t last_nonblank; /*|last| with trailing blanks removed*/ 
-if (bypass_eoln) if (!eof((*f))) get((*f));
+if (bypass_eoln) if (!eof((*f))) (*f).d=fgetwc((*f).f);
    /*input the first character of the line into |f.d|*/ 
 last=first; /*cf.\ Matthew 19\thinspace:\thinspace30*/ 
 if (eof((*f))) return false;
@@ -950,7 +953,7 @@
       if (max_buf_stack==buf_size) 
         @<Report overflow of the input buffer, and abort@>;
       } 
-    buffer[last]=xord[(*f).d];get((*f));incr(last);
+    buffer[last]=xord[(*f).d];(*f).d=fgetwc((*f).f);incr(last);
     if (buffer[last-1]!=' ') last_nonblank=last;
     } 
   last=last_nonblank;return true;
@@ -1069,11 +1072,11 @@
 @p bool init_terminal(void) /*gets the terminal input started*/ 
 {@+
 t_open_in;
-loop@+{@+wake_up_terminal;write(term_out,"**");update_terminal;
+loop@+{@+wake_up_terminal;write(term_out,L"**");update_terminal;
 @.**@>
   if (!input_ln(&term_in, true))  /*this shouldn't happen*/ 
     {@+write_ln(term_out);
-    write(term_out,"! End of file on the terminal... why?");
+    write(term_out,L"! End of file on the terminal... why?");
 @.End of file on the terminal@>
     return false;
     } 
@@ -1461,15 +1464,15 @@
 #define read(file,x) @[((x)=(file).d,get(file))@]
 #define read_ln(file)  @[do get(file); while (!eoln(file))@]
 
-#define write(file, format,...)    @[fprintf(file.f,format,## __VA_ARGS__)@]
-#define write_ln(file,...)	   @[write(file,__VA_ARGS__"\n")@]
+#define write(file, format,...)    @[fwprintf(file.f,format,## __VA_ARGS__)@]
+#define write_ln(file,...)	   @[write(file,__VA_ARGS__ L"\n")@]
 
 #define wterm(format,...)	@[write(term_out,format, ## __VA_ARGS__)@]
-#define wterm_ln(format,...)	@[wterm(format "\n", ## __VA_ARGS__)@]
-#define wterm_cr	        @[write(term_out,"\n")@]
+#define wterm_ln(format,...)	@[wterm(format L"\n", ## __VA_ARGS__)@]
+#define wterm_cr	        @[write(term_out,L"\n")@]
 #define wlog(format, ...)	@[write(log_file,format, ## __VA_ARGS__)@]
-#define wlog_ln(format, ...)   @[wlog(format "\n", ## __VA_ARGS__)@]
-#define wlog_cr	        @[write(log_file,"\n")@]
+#define wlog_ln(format, ...)   @[wlog(format L"\n", ## __VA_ARGS__)@]
+#define wlog_cr	        @[write(log_file,L"\n")@]
 
 @ To end a line of text output, we call |print_ln|.
 
@@ -1500,7 +1503,7 @@
   {@+print_ln();return;
   } 
 switch (selector) {
-case term_and_log: {@+wterm("%c",xchr[s]);wlog("%c",xchr[s]);
+case term_and_log: {@+wterm(L"%lc",xchr[s]);wlog(L"%lc",xchr[s]);
   incr(term_offset);incr(file_offset);
   if (term_offset==max_print_line) 
     {@+wterm_cr;term_offset=0;
@@ -1509,17 +1512,17 @@
     {@+wlog_cr;file_offset=0;
     } 
   } @+break;
-case log_only: {@+wlog("%c",xchr[s]);incr(file_offset);
+case log_only: {@+wlog(L"%lc",xchr[s]);incr(file_offset);
   if (file_offset==max_print_line) print_ln();
   } @+break;
-case term_only: {@+wterm("%c",xchr[s]);incr(term_offset);
+case term_only: {@+wterm(L"%lc",xchr[s]);incr(term_offset);
   if (term_offset==max_print_line) print_ln();
   } @+break;
 case no_print: do_nothing;@+break;
 case pseudo: if (tally < trick_count) trick_buf[tally%error_line]=s;@+break;
 case new_string: {@+if (pool_ptr < pool_size) append_char(s);
   } @+break; /*we drop characters if the string space is full*/ 
-default:write(write_file[selector],"%c", xchr[s]);
+default:write(write_file[selector],L"%lc", xchr[s]);
 } @/
 incr(tally);
 } 
@@ -1588,8 +1591,8 @@
 character positions.
 
 @<Initialize the output...@>=
-wterm("%s",banner);
-if (format_ident==0) wterm_ln(" (no format preloaded)");
+wterm(L"%s",banner);
+if (format_ident==0) wterm_ln(L" (no format preloaded)");
 else{@+slow_print(format_ident);print_ln();
   } 
 update_terminal;
@@ -10110,9 +10113,16 @@
 allows both lowercase and uppercase letters in the file name.
 @^system dependencies@>
 
-@d append_to_name(X)	{@+c=X;incr(k);
-  if (k <= file_name_size) name_of_file[k]=xchr[c];
-  } 
+@d append_to_name(X)	{@+c=X;
+  if (k >= 0) {
+    char mb[MB_CUR_MAX];
+    int len = wctomb(mb, xchr[c]);
+    if (k+len <= file_name_size)
+      for (int i = 0; i < len; i++) name_of_file[++k] = mb[i];
+    else
+      k = -k;
+  }
+}
 
 @p void pack_file_name(str_number @!n, str_number @!a, str_number @!e)
 {@+int k; /*number of positions filled in |name_of_file|*/ 
@@ -10122,6 +10132,7 @@
 for (j=str_start[a]; j<=str_start[a+1]-1; j++) append_to_name(so(str_pool[j]));
 for (j=str_start[n]; j<=str_start[n+1]-1; j++) append_to_name(so(str_pool[j]));
 for (j=str_start[e]; j<=str_start[e+1]-1; j++) append_to_name(so(str_pool[j]));
+if (k < 0) k = -k;
 if (k <= file_name_size) name_length=k;@+else name_length=file_name_size;
 name_of_file[name_length+1]=0;
 } 
@@ -10138,13 +10149,13 @@
 @d format_extension_str ".fmt" /*the extension, as a \.{WEB} constant*/ 
 
 @<Glob...@>=
-ASCII_code @!TEX_format_default[1+format_default_length+1]=" TeXformats/plain.fmt";
+wchar_t @!TEX_format_default[1+format_default_length+1]=L" TeXformats/plain.fmt";
 @.TeXformats@>
 @.plain@>
 @^system dependencies@>
 
 @ @<Check the ``constant'' values for consistency@>=
-if (format_default_length > file_name_size) bad=31;
+if (wcstombs(NULL,TEX_format_default+1,0) > file_name_size) bad=31;
 
 @ Here is the messy routine that was just mentioned. It sets |name_of_file|
 from the first |n| characters of |TEX_format_default|, followed by
@@ -10161,11 +10172,16 @@
 {@+int k; /*number of positions filled in |name_of_file|*/ 
 ASCII_code @!c; /*character being packed*/ 
 int @!j; /*index into |buffer| or |TEX_format_default|*/ 
-if (n+b-a+1+format_ext_length > file_name_size) 
-  b=a+file_name_size-n-1-format_ext_length;
 k=0;
 for (j=1; j<=n; j++) append_to_name(xord[TEX_format_default[j]]);
 for (j=a; j<=b; j++) append_to_name(buffer[j]);
+if (k < 0) k = -k;
+while (k+wcstombs(NULL,TEX_format_default+format_default_length
+       -format_ext_length+1,0) > file_name_size) {
+  k--;
+  while(mblen(name_of_file+k+1, MB_CUR_MAX)==-1)
+    k--;
+}
 for (j=format_default_length-format_ext_length+1; j<=format_default_length; j++) 
   append_to_name(xord[TEX_format_default[j]]);
 if (k <= file_name_size) name_length=k;@+else name_length=file_name_size;
@@ -10193,7 +10209,7 @@
      /*now try the system format file area*/ 
   if (w_open_in(&fmt_file)) goto found;
   wake_up_terminal;
-  wterm_ln("Sorry, I can't find that format; will try PLAIN.");
+  wterm_ln(L"Sorry, I can't find that format; will try PLAIN.");
 @.Sorry, I can't find...@>
   update_terminal;
   } 
@@ -10201,7 +10217,7 @@
 pack_buffered_name(format_default_length-format_ext_length, 1, 0);
 if (!w_open_in(&fmt_file)) 
   {@+wake_up_terminal;
-  wterm_ln("I can't find the PLAIN format file!");
+  wterm_ln(L"I can't find the PLAIN format file!");
 @.I can't find PLAIN...@>
 @.plain@>
   return false;
@@ -10224,7 +10240,11 @@
 if ((pool_ptr+name_length > pool_size)||(str_ptr==max_strings)||
  (cur_length > 0)) 
   return'?';
-else{@+for (k=1; k<=name_length; k++) append_char(xord[name_of_file[k]]);
+else{@+for (k=1; k<=name_length; k++) {
+      wchar_t wc;
+      k += mbtowc(&wc, name_of_file+k, MB_CUR_MAX) - 1;
+      append_char(xord[wc]);
+    }
   return make_string();
   } 
 } 
@@ -10394,10 +10414,10 @@
 } 
 
 @ @<Print the banner...@>=
-{@+wlog("%s",banner);
+{@+wlog(L"%s",banner);
 slow_print(format_ident);print_str("  ");
 print_int(day);print_char(' ');
-for (k=3*month-2; k<=3*month; k++) wlog("%c",months[k]);
+for (k=3*month-2; k<=3*month; k++) wlog(L"%c",months[k]);
 print_char(' ');print_int(year);print_char(' ');
 print_two(time/60);print_char(':');print_two(time%60);
 } 
@@ -11958,7 +11978,7 @@
 
 @p void write_dvi(dvi_index @!a, dvi_index @!b)
 {@+int k;
-for (k=a; k<=b; k++) write(dvi_file, "%c", dvi_buf[k]);
+for (k=a; k<=b; k++) fprintf(dvi_file.f, "%c", dvi_buf[k]);
 } 
 
 @ To put a byte in the buffer without paying the cost of invoking a procedure
@@ -23781,7 +23801,7 @@
 incompatible with the present \TeX\ table sizes, etc.
 
 @d too_small(X)	{@+wake_up_terminal;
-  wterm_ln("---! Must increase the %s", X);
+  wterm_ln(L"---! Must increase the %s", X);
 @.Must increase the x@>
   goto bad_fmt;
   } 
@@ -23802,7 +23822,7 @@
 @<Undump a couple more things and the closing check word@>;
 return true; /*it worked!*/ 
 bad_fmt: wake_up_terminal;
-  wterm_ln("(Fatal format file error; I'm stymied)");
+  wterm_ln(L"(Fatal format file error; I'm stymied)");
 @.Fatal format file error@>
 return false;
 } 
@@ -24289,13 +24309,14 @@
 @^system dependencies@>
 
 @p int main(void) {@! /*|start_here|*/ 
+setlocale(LC_CTYPE, "C.UTF-8");
 history=fatal_error_stop; /*in case we quit during initialization*/ 
 t_open_out; /*open the terminal for output*/ 
 if (ready_already==314159) goto start_of_TEX;
 @<Check the ``constant'' values...@>@;
 if (bad > 0) 
-  {@+wterm_ln("Ouch---my internal constants have been clobbered!"
-    "---case %d", bad);
+  {@+wterm_ln(L"Ouch---my internal constants have been clobbered!"
+    L"---case %d", bad);
 @.Ouch...clobbered@>
   exit(0);
   } 
@@ -24352,24 +24373,24 @@
 
 @<Output statistics...@>=
 if (log_opened) 
-  {@+wlog_ln(" ");
-  wlog_ln("Here is how much of TeX's memory you used:");
+  {@+wlog_ln(L" ");
+  wlog_ln(L"Here is how much of TeX's memory you used:");
 @.Here is how much...@>
-  wlog(" %d string", str_ptr-init_str_ptr);
-  if (str_ptr!=init_str_ptr+1) wlog( "s" );
-  wlog_ln( " out of %d", max_strings-init_str_ptr);@/
-  wlog_ln( " %d string characters out of %d", pool_ptr-init_pool_ptr,
+  wlog(L" %d string", str_ptr-init_str_ptr);
+  if (str_ptr!=init_str_ptr+1) wlog( L"s" );
+  wlog_ln( L" out of %d", max_strings-init_str_ptr);@/
+  wlog_ln( L" %d string characters out of %d", pool_ptr-init_pool_ptr,
     pool_size-init_pool_ptr);@/
-  wlog_ln(" %d words of memory out of %d", lo_mem_max-mem_min+mem_end-hi_mem_min+2,@|
+  wlog_ln(L" %d words of memory out of %d", lo_mem_max-mem_min+mem_end-hi_mem_min+2,@|
     mem_end+1-mem_min);@/
-  wlog_ln(" %d multiletter control sequences out of %d", cs_count, hash_size);@/
-  wlog(" %d words of font info for %d font", fmem_ptr, font_ptr-font_base);
-  if (font_ptr!=font_base+1) wlog("s");
-  wlog_ln( ", out of %d for %d", font_mem_size, font_max-font_base);@/
-  wlog(" %d hyphenation exception", hyph_count);
-  if (hyph_count!=1) wlog("s");
-  wlog_ln( " out of %d", hyph_size);@/
-  wlog_ln(" %di,%dn,%dp,%db,%ds stack positions out of %di,%dn,%dp,%db,%ds", 
+  wlog_ln(L" %d multiletter control sequences out of %d", cs_count, hash_size);@/
+  wlog(L" %d words of font info for %d font", fmem_ptr, font_ptr-font_base);
+  if (font_ptr!=font_base+1) wlog(L"s");
+  wlog_ln( L", out of %d for %d", font_mem_size, font_max-font_base);@/
+  wlog(L" %d hyphenation exception", hyph_count);
+  if (hyph_count!=1) wlog(L"s");
+  wlog_ln( L" out of %d", hyph_size);@/
+  wlog_ln(L" %di,%dn,%dp,%db,%ds stack positions out of %di,%dn,%dp,%db,%ds",
     max_in_stack, max_nest_stack,@|
     max_param_stack,@|
     max_buf_stack+1,@|
